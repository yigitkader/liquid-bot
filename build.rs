use std::env;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=idl/solend.json");
    println!("cargo:rerun-if-changed=idl/switchboard.json");
    
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    
    // Read IDL from local idl/*.json files per Structure.md section 11.5
    // build.rs does NOT download from internet - it reads from pre-generated JSON files
    let idl_path = PathBuf::from("idl/solend.json");
    if !idl_path.exists() {
        panic!("IDL file not found: idl/solend.json\nPlease run the layout dump script first (see Structure.md section 11)");
    }
    
    let idl_content = fs::read_to_string(&idl_path)
        .expect("Failed to read idl/solend.json");
    
    // Save build-time IDL version/metadata for runtime validation
    let idl: serde_json::Value = serde_json::from_str(&idl_content)
        .expect("Failed to parse IDL JSON");
    
    // Extract version/metadata for runtime validation
    let idl_version = idl.get("version").and_then(|v| v.as_str()).unwrap_or("unknown");
    let idl_name = idl.get("name").and_then(|n| n.as_str()).unwrap_or("unknown");
    
    // Write build-time IDL metadata to OUT_DIR for runtime comparison
    let metadata = format!(
        r#"pub const BUILD_TIME_IDL_VERSION: &str = "{}";
pub const BUILD_TIME_IDL_NAME: &str = "{}";
pub const BUILD_TIME_IDL_CONTENT_HASH: &str = "{}";
"#,
        idl_version,
        idl_name,
        calculate_hash(&idl_content)
    );
    fs::write(out_dir.join("idl_metadata.rs"), metadata)
        .expect("Failed to write IDL metadata");
    
    let idl: serde_json::Value = serde_json::from_str(&idl_content)
        .expect("Failed to parse IDL JSON");
    
    // Collect all type definitions first
    let mut type_defs: HashMap<String, Vec<serde_json::Value>> = HashMap::new();
    
    // Process accounts section
    if let Some(accounts) = idl.get("accounts").and_then(|a| a.as_array()) {
        for account in accounts {
            if let Some(name) = account.get("name").and_then(|n| n.as_str()) {
                if let Some(ty) = account.get("type") {
                    // Handle struct types with fields
                    if let Some(fields) = ty.get("fields").and_then(|f| f.as_array()) {
                        type_defs.insert(name.to_string(), fields.clone());
                    }
                    // Handle types without fields (like Number which is in accounts but might be simple)
                    else if ty.get("kind").is_none() {
                        // This might be a simple type - check if it's in types section
                        // For now, skip if no fields
                    }
                }
            }
        }
    }
    
    // Process types section
    if let Some(types) = idl.get("types").and_then(|t| t.as_array()) {
        for ty in types {
            if let Some(name) = ty.get("name").and_then(|n| n.as_str()) {
                if let Some(ty_def) = ty.get("type") {
                    if let Some(fields) = ty_def.get("fields").and_then(|f| f.as_array()) {
                        // Don't override if already exists from accounts
                        type_defs.entry(name.to_string()).or_insert_with(|| fields.clone());
                    }
                }
            }
        }
    }
    
    // Generate Rust code (no imports - they're in solend.rs)
    let mut rust_code = String::from(
        "// Auto-generated Solend account layouts from IDL\n\
        // DO NOT EDIT MANUALLY - Generated by build.rs\n\n"
    );
    
    // Generate all types (don't skip any)
    for (name, fields) in &type_defs {
        // Skip enum markers
        if name.ends_with("_ENUM") {
            continue;
        }
        rust_code.push_str(&generate_struct(name, fields, &type_defs));
        rust_code.push('\n');
    }
    
    // Write generated code
    let output_path = out_dir.join("solend_layout.rs");
    fs::write(&output_path, rust_code)
        .expect("Failed to write solend_layout.rs");
    
    println!("cargo:warning=Generated Solend layouts at {:?}", output_path);
}


fn calculate_hash(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}

fn is_simple_type(fields: &[serde_json::Value], _type_defs: &HashMap<String, Vec<serde_json::Value>>) -> bool {
    // Check if all fields are primitive types
    for field in fields {
        if let Some(field_type) = field.get("type") {
            if let serde_json::Value::Object(obj) = field_type {
                if let Some(kind) = obj.get("kind").and_then(|k| k.as_str()) {
                    if kind == "defined" {
                        // Check if it's a simple defined type (like Number)
                        if let Some(name) = obj.get("defined").and_then(|d| d.as_str()) {
                            if name == "Number" {
                                continue; // Number is simple
                            }
                            return false; // Other defined types might have dependencies
                        }
                    } else if kind != "vec" && kind != "option" {
                        return false;
                    }
                }
            }
        }
    }
    true
}

fn generate_struct(name: &str, fields: &[serde_json::Value], type_defs: &HashMap<String, Vec<serde_json::Value>>) -> String {
    let mut code = format!("#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]\npub struct {} {{\n", name);
    
    for field in fields {
        if let Some(field_name) = field.get("name").and_then(|n| n.as_str()) {
            if let Some(field_type) = field.get("type") {
                let rust_type = idl_type_to_rust(field_type, type_defs);
                code.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
            }
        }
    }
    
    code.push_str("}\n");
    code
}

fn idl_type_to_rust(ty: &serde_json::Value, type_defs: &HashMap<String, Vec<serde_json::Value>>) -> String {
    match ty {
        serde_json::Value::String(s) => {
            match s.as_str() {
                "u8" => "u8".to_string(),
                "u64" => "u64".to_string(),
                "u128" => "u128".to_string(),
                "bool" => "bool".to_string(),
                "publicKey" => "Pubkey".to_string(),
                "bytes" => "Vec<u8>".to_string(),
                "string" => "String".to_string(),
                _ => {
                    // Check if it's a defined type
                    if type_defs.contains_key(s) {
                        s.to_string()
                    } else if s.ends_with("_ENUM") {
                        // Enum placeholder - use u8 for now
                        "u8".to_string()
                    } else if s == "SwitchboardPermission" || s == "VrfStatus" || s == "AggregatorResolutionMode" {
                        // External types from other IDLs - use u8 placeholder
                        "u8".to_string()
                    } else {
                        // Unknown type - try to use as-is (might be a defined type from types section)
                        format!("{}", s)
                    }
                }
            }
        }
        serde_json::Value::Object(obj) => {
            // Check for "defined" key first (IDL format: { "defined": "TypeName" })
            if let Some(name) = obj.get("defined").and_then(|d| d.as_str()) {
                return name.to_string();
            }
            
            // Check for "kind" key (Anchor format: { "kind": "vec", "vec": {...} })
            if let Some(kind) = obj.get("kind").and_then(|k| k.as_str()) {
                match kind {
                    "vec" => {
                        if let Some(inner) = obj.get("vec") {
                            let inner_type = idl_type_to_rust(inner, type_defs);
                            format!("Vec<{}>", inner_type)
                        } else {
                            "Vec<u8>".to_string()
                        }
                    }
                    "option" => {
                        if let Some(inner) = obj.get("option") {
                            let inner_type = idl_type_to_rust(inner, type_defs);
                            format!("Option<{}>", inner_type)
                        } else {
                            "Option<u8>".to_string()
                        }
                    }
                    "defined" => {
                        if let Some(name) = obj.get("defined").and_then(|d| d.as_str()) {
                            name.to_string()
                        } else {
                            "u8".to_string()
                        }
                    }
                    "array" => {
                        if let Some(size) = obj.get("size").and_then(|s| s.as_u64()) {
                            if let Some(ty) = obj.get("type") {
                                let inner_type = idl_type_to_rust(ty, type_defs);
                                format!("[{}; {}]", inner_type, size)
                            } else {
                                format!("[u8; {}]", size)
                            }
                        } else {
                            "[u8; 1]".to_string()
                        }
                    }
                    _ => "u8".to_string(),
                }
            } else {
                // Check for direct "vec" key (IDL format: { "vec": {...} })
                if obj.contains_key("vec") {
                    if let Some(inner) = obj.get("vec") {
                        let inner_type = idl_type_to_rust(inner, type_defs);
                        format!("Vec<{}>", inner_type)
                    } else {
                        "Vec<u8>".to_string()
                    }
                } else {
                    "u8".to_string()
                }
            }
        }
        _ => "u8".to_string(),
    }
}
